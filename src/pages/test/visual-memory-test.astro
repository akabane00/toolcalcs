---
import BaseLayout from '../../layouts/BaseLayout.astro';
import AdUnit from '../../components/AdUnit.astro';
import { getGameBySlug } from '../../data/games';
import '../../styles/game.css';

const game = getGameBySlug('visual-memory-test')!;

const structuredData = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://toolcalcs.com/" },
    { "@type": "ListItem", "position": 2, "name": "Tests & Games", "item": "https://toolcalcs.com/test/" },
    { "@type": "ListItem", "position": 3, "name": "Visual Memory Test" }
  ]
};
---

<BaseLayout
  title="Visual Memory Test - Test Your Short-Term Visual Memory | ToolCalcs"
  description="Test your visual short-term memory by remembering tile patterns on a grid. Each level adds more tiles to memorize. Free online visual memory game with score tracking."
  type="article"
  structuredData={structuredData}
>
  <nav class="breadcrumb" aria-label="Breadcrumb">
    <a href="/">Home</a> &rsaquo;
    <a href="/test/">Tests & Games</a> &rsaquo;
    <span>Visual Memory Test</span>
  </nav>

  <h1>Visual Memory Test</h1>
  <p class="page-desc">Memorize the highlighted tiles, then click them from memory. Each level adds more tiles to remember.</p>

  <div class="game-box">
    <div class="game-area" id="gameArea" role="region" aria-label="Visual memory test area" aria-live="polite">
      <div class="game-instructions" id="instructionsView">
        <h2>Visual Memory</h2>
        <p>Tiles will briefly light up on a grid. After they disappear, click the tiles that were highlighted. You have 3 lives.</p>
        <button class="game-btn primary" id="startBtn" type="button" style="margin-top:16px;">Start Test</button>
      </div>

      <div class="play-view" id="playView" style="display:none;">
        <div class="status-bar">
          <span class="level-info" id="levelInfo">Level 1</span>
          <span class="lives-info" id="livesInfo">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
        </div>
        <div class="vm-grid" id="vmGrid" role="grid" aria-label="Memory grid"></div>
      </div>

      <div class="result-view" id="resultView" style="display:none;">
        <div class="result-icon" aria-hidden="true">üëÅÔ∏è</div>
        <div class="result-label">Game Over</div>
        <div class="score-display">
          <span class="score-value" id="finalScore">0</span>
          <span class="score-unit">levels completed</span>
        </div>
        <div class="rating-badge" id="ratingBadge">‚Äî</div>
        <button class="game-btn primary" id="tryAgainBtn" type="button" style="margin-top:16px;">Try Again</button>
      </div>
    </div>

    <div class="attempt-history" id="attemptHistory" hidden>
      <h3>Attempt History</h3>
      <div class="history-list" id="historyList"></div>
    </div>
  </div>

  <AdUnit slot="game-mid" format="horizontal" />

  <article class="content-section">
    <h2>What Is the Visual Memory Test?</h2>
    <p>The Visual Memory Test measures your ability to remember and recall spatial patterns. It is based on the Corsi block-tapping task, a widely used neuropsychological test developed by Philip Corsi in 1972. In the original version, an examiner taps a sequence of blocks and the participant must replicate the pattern. This digital adaptation presents highlighted tiles on a grid that you must identify from memory.</p>
    <p>Visual-spatial short-term memory is distinct from verbal memory (like remembering numbers or words). It engages the visuospatial sketchpad, a component of working memory described by Alan Baddeley's model, which processes and stores visual and spatial information.</p>

    <h2>How This Test Works</h2>
    <p>Each round, a grid of tiles appears with several tiles briefly highlighted in white. After the tiles fade, you must click the ones that were highlighted. The test begins with a small grid and few tiles, progressively increasing both the grid size and the number of tiles to remember.</p>
    <ul>
      <li><strong>Level 1-3:</strong> Small grid (3√ó3), 3-5 tiles highlighted. A warm-up to establish the pattern.</li>
      <li><strong>Level 4-7:</strong> Medium grid (4√ó4), 5-8 tiles. Requires focused attention and mental imagery.</li>
      <li><strong>Level 8-12:</strong> Larger grid (5√ó5), 8-12 tiles. Challenges even people with strong visual memory.</li>
      <li><strong>Level 13+:</strong> Large grids (6√ó6+) with many tiles. Only those with exceptional visual memory reach this stage.</li>
    </ul>
    <p>You have 3 lives. Each time you click an incorrect tile, you lose one life. The game ends when all lives are lost.</p>

    <h2>Visual-Spatial Memory in Daily Life</h2>
    <p>Visual-spatial memory plays a crucial role in many everyday activities that you may take for granted:</p>
    <ul>
      <li><strong>Navigation:</strong> Remembering routes, mental maps, and spatial relationships between landmarks.</li>
      <li><strong>Reading:</strong> Tracking your position on a page and remembering the layout of text and diagrams.</li>
      <li><strong>Sports:</strong> Remembering positions of players, anticipating movements, and spatial awareness on the field.</li>
      <li><strong>Art and design:</strong> Visualizing compositions, color arrangements, and spatial relationships between elements.</li>
      <li><strong>Problem solving:</strong> Mental rotation of objects, visualizing solutions, and spatial reasoning in mathematics.</li>
    </ul>

    <h2>Tips to Improve Visual Memory</h2>
    <ul>
      <li><strong>Chunking:</strong> Group tiles into shapes or patterns rather than memorizing individual positions. Your brain naturally remembers patterns more efficiently than isolated data points.</li>
      <li><strong>Spatial anchoring:</strong> Use the edges and corners of the grid as reference points. Note which highlighted tiles are near edges versus the center.</li>
      <li><strong>Mental photography:</strong> Try to take a mental "snapshot" of the entire pattern rather than scanning tiles sequentially.</li>
      <li><strong>Regular practice:</strong> Visual-spatial working memory is trainable. Research shows consistent practice leads to measurable improvements over weeks.</li>
      <li><strong>Reduce distractions:</strong> Focus entirely on the screen during the display phase. Even brief distractions can disrupt spatial encoding.</li>
    </ul>

    <h2>The Science Behind Visual Memory</h2>
    <p>Visual-spatial working memory is primarily processed in the right hemisphere of the brain, with key areas including the parietal cortex (spatial processing), the occipital cortex (visual processing), and the prefrontal cortex (executive control). Neuroimaging studies show that visual memory tasks activate a network that differs from verbal memory tasks, supporting the idea that these are distinct cognitive systems.</p>
    <p>The average adult visual-spatial memory span is about 5-7 items, similar to verbal memory. However, this capacity can be effectively expanded through chunking strategies ‚Äî grouping individual items into meaningful patterns. Expert chess players, for example, can remember complex board positions not because they have larger memory capacity, but because they chunk pieces into familiar patterns.</p>
    <p>Age, sleep quality, stress, and physical exercise all affect visual memory performance. Regular aerobic exercise has been shown to improve spatial memory, while chronic sleep deprivation impairs it. Mindfulness meditation has also shown promise in enhancing visual-spatial working memory capacity.</p>
  </article>

  <AdUnit slot="game-bottom" format="horizontal" />
</BaseLayout>

<style>
  .game-area { cursor: default; user-select: auto; -webkit-user-select: auto; }

  .status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
  }
  .level-info { font-weight: 700; font-size: 1rem; color: var(--color-text); }
  .lives-info { font-size: 1.2rem; }

  .vm-grid {
    display: grid;
    gap: 4px;
    padding: 16px;
    max-width: 400px;
    margin: 0 auto;
  }
  :global(.vm-tile) {
    aspect-ratio: 1;
    border-radius: 6px;
    border: none;
    padding: 0;
    cursor: pointer;
    background: var(--color-border);
    transition: background 0.2s, transform 0.1s;
  }
  :global(.vm-tile.showing) {
    background: #fff;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
  }
  :global(.vm-tile.correct) {
    background: #22c55e;
    cursor: default;
  }
  :global(.vm-tile.wrong) {
    background: #ef4444;
    animation: wrongPulse 0.4s ease;
  }
  :global(.vm-tile:not(.correct):not(.wrong):not(.showing):hover) {
    background: var(--color-text-muted);
    transform: scale(0.95);
  }
  @keyframes wrongPulse {
    0% { transform: scale(1); }
    25% { transform: translateX(-3px); }
    50% { transform: translateX(3px); }
    75% { transform: translateX(-3px); }
    100% { transform: scale(1); }
  }

  .play-view {
    min-height: 280px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  .result-view {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 280px;
    padding: 24px;
  }
  .result-icon { font-size: 3rem; margin-bottom: 8px; }
  .result-label {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-text-muted);
    margin-bottom: 12px;
  }
</style>

<script>
  (function () {
    'use strict';

    const RATING_SCALE = [
      { min: 14, label: 'Exceptional!', color: '#16a34a' },
      { min: 11, label: 'Great!', color: '#22c55e' },
      { min: 8, label: 'Good', color: '#2563eb' },
      { min: 5, label: 'Average', color: '#f59e0b' },
      { min: 0, label: 'Below Average', color: '#ef4444' },
    ];

    function getLocalRating(score: number) {
      for (const level of RATING_SCALE) {
        if (score >= level.min) return { label: level.label, color: level.color };
      }
      return { label: 'Below Average', color: '#ef4444' };
    }

    const STORAGE_KEY = 'toolcalcs_visual-memory-test_history';
    const MAX_HISTORY = 20;

    function loadHistory(): Array<{ score: number; date: string; rating: string }> {
      try { const r = localStorage.getItem(STORAGE_KEY); if (r) return JSON.parse(r); } catch {}
      return [];
    }
    function saveHistory(h: Array<{ score: number; date: string; rating: string }>) {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(h.slice(0, MAX_HISTORY))); } catch {}
    }
    function addToHistory(score: number) {
      const h = loadHistory();
      h.unshift({ score, date: new Date().toISOString(), rating: getLocalRating(score).label });
      saveHistory(h);
    }

    // DOM
    const instructionsView = document.getElementById('instructionsView')!;
    const playView = document.getElementById('playView')!;
    const resultView = document.getElementById('resultView')!;
    const startBtn = document.getElementById('startBtn')!;
    const tryAgainBtn = document.getElementById('tryAgainBtn')!;
    const levelInfo = document.getElementById('levelInfo')!;
    const livesInfo = document.getElementById('livesInfo')!;
    const vmGrid = document.getElementById('vmGrid')!;
    const finalScore = document.getElementById('finalScore')!;
    const ratingBadge = document.getElementById('ratingBadge')!;
    const attemptHistorySection = document.getElementById('attemptHistory')!;
    const historyList = document.getElementById('historyList')!;

    let currentLevel = 1;
    let lives = 3;
    let isPlaying = false;
    let canClick = false;
    let highlightedSet = new Set<number>();
    let foundSet = new Set<number>();

    function showView(view: HTMLElement) {
      [instructionsView, playView, resultView].forEach(v => v.style.display = 'none');
      view.style.display = '';
    }

    function getLevelConfig(level: number) {
      const tileCount = level + 2; // Level 1=3, Level 2=4, ...
      let gridSize: number;
      if (tileCount <= 4) gridSize = 3;
      else if (tileCount <= 7) gridSize = 4;
      else if (tileCount <= 12) gridSize = 5;
      else if (tileCount <= 18) gridSize = 6;
      else gridSize = 7;
      return { gridSize, tileCount: Math.min(tileCount, gridSize * gridSize - 1) };
    }

    function shuffleArray(arr: number[]): number[] {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function startRound() {
      const { gridSize, tileCount } = getLevelConfig(currentLevel);
      const totalTiles = gridSize * gridSize;

      // Pick random tiles to highlight
      const indices = Array.from({ length: totalTiles }, (_, i) => i);
      shuffleArray(indices);
      highlightedSet = new Set(indices.slice(0, tileCount));
      foundSet = new Set();
      canClick = false;

      // Render grid
      vmGrid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
      vmGrid.innerHTML = '';

      for (let i = 0; i < totalTiles; i++) {
        const btn = document.createElement('button');
        btn.className = 'vm-tile';
        btn.dataset.index = String(i);
        btn.setAttribute('aria-label', `Tile ${i + 1}`);
        vmGrid.appendChild(btn);
      }

      levelInfo.textContent = `Level ${currentLevel}`;
      livesInfo.textContent = '‚ù§Ô∏è'.repeat(lives);

      // Show highlighted tiles
      highlightedSet.forEach(idx => {
        const tile = vmGrid.children[idx] as HTMLElement;
        tile.classList.add('showing');
      });

      // Hide after delay (longer for more tiles)
      const showTime = Math.min(2500, 800 + tileCount * 120);
      setTimeout(() => {
        highlightedSet.forEach(idx => {
          const tile = vmGrid.children[idx] as HTMLElement;
          tile.classList.remove('showing');
        });
        canClick = true;
      }, showTime);
    }

    function handleTileClick(e: Event) {
      if (!isPlaying || !canClick) return;
      const target = (e.target as HTMLElement).closest('.vm-tile') as HTMLElement | null;
      if (!target) return;
      const idx = parseInt(target.dataset.index || '-1');
      if (idx < 0 || foundSet.has(idx)) return;
      if (target.classList.contains('correct') || target.classList.contains('wrong')) return;

      if (highlightedSet.has(idx)) {
        // Correct
        foundSet.add(idx);
        target.classList.add('correct');
        target.style.cursor = 'default';

        if (foundSet.size === highlightedSet.size) {
          // Level complete
          canClick = false;
          currentLevel++;
          setTimeout(() => startRound(), 500);
        }
      } else {
        // Wrong
        target.classList.add('wrong');
        lives--;
        livesInfo.textContent = '‚ù§Ô∏è'.repeat(Math.max(0, lives));

        if (lives <= 0) {
          canClick = false;
          // Reveal remaining
          highlightedSet.forEach(i => {
            if (!foundSet.has(i)) {
              const tile = vmGrid.children[i] as HTMLElement;
              tile.classList.add('showing');
            }
          });
          setTimeout(() => endGame(), 800);
        }
      }
    }

    function startGame() {
      currentLevel = 1;
      lives = 3;
      isPlaying = true;
      showView(playView);
      startRound();
    }

    function endGame() {
      isPlaying = false;
      const score = currentLevel - 1;
      showView(resultView);
      finalScore.textContent = String(score);
      const rating = getLocalRating(score);
      ratingBadge.textContent = rating.label;
      ratingBadge.style.background = rating.color;
      addToHistory(score);
      renderHistory();
    }

    function renderHistory() {
      const history = loadHistory();
      if (history.length === 0) { attemptHistorySection.hidden = true; return; }
      attemptHistorySection.hidden = false;
      historyList.innerHTML = history.map(e => {
        const r = getLocalRating(e.score);
        return `<div class="history-item">
          <span class="history-score">${e.score} levels</span>
          <span class="history-rating" style="background:${r.color}">${r.label}</span>
          <span class="history-time">${formatDate(e.date)}</span>
        </div>`;
      }).join('');
    }

    function formatDate(iso: string): string {
      try { return new Date(iso).toLocaleDateString(undefined, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }); }
      catch { return ''; }
    }

    vmGrid.addEventListener('click', handleTileClick);
    startBtn.addEventListener('click', startGame);
    tryAgainBtn.addEventListener('click', startGame);
    renderHistory();
  })();
</script>
