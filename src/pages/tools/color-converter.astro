---
import BaseLayout from '../../layouts/BaseLayout.astro';
import AdUnit from '../../components/AdUnit.astro';
import { getToolBySlug } from '../../data/tools';
import '../../styles/tool.css';

const tool = getToolBySlug('color-converter')!;

const structuredData = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position": 1,
      "name": "Home",
      "item": "https://toolcalcs.com/"
    },
    {
      "@type": "ListItem",
      "position": 2,
      "name": "Web Tools",
      "item": "https://toolcalcs.com/tools/"
    },
    {
      "@type": "ListItem",
      "position": 3,
      "name": "Color Converter"
    }
  ]
};
---

<BaseLayout
  title="Color Converter - HEX, RGB & HSL Converter | ToolCalcs"
  description="Free color converter tool. Convert colors between HEX, RGB, and HSL formats instantly with a live preview. Copy color values in any format."
  type="article"
  structuredData={structuredData}
>
  <nav class="breadcrumb">
    <a href="/">Home</a> &rsaquo;
    <a href="/tools/">Web Tools</a> &rsaquo;
    <span>Color Converter</span>
  </nav>

  <h1>{tool.title}</h1>
  <p class="page-desc">{tool.description}</p>

  <div class="tool-box">
    <div class="tool-preview" id="colorPreview" style="background-color: #3b82f6;"></div>

    <div class="color-picker-row">
      <label class="tool-label" for="colorPicker">Pick a Color</label>
      <input type="color" id="colorPicker" value="#3b82f6" />
    </div>

    <div class="color-formats">
      <div class="format-row">
        <label class="tool-label" for="hexInput">HEX</label>
        <div class="format-inputs">
          <input type="text" id="hexInput" value="#3b82f6" maxlength="7" spellcheck="false" autocomplete="off" />
        </div>
        <button type="button" class="copy-btn" data-format="hex">Copy</button>
      </div>

      <div class="format-row">
        <label class="tool-label">RGB</label>
        <div class="format-inputs rgb-inputs">
          <div class="number-field">
            <span class="field-hint">R</span>
            <input type="number" id="rgbR" min="0" max="255" value="59" />
          </div>
          <div class="number-field">
            <span class="field-hint">G</span>
            <input type="number" id="rgbG" min="0" max="255" value="130" />
          </div>
          <div class="number-field">
            <span class="field-hint">B</span>
            <input type="number" id="rgbB" min="0" max="255" value="246" />
          </div>
        </div>
        <button type="button" class="copy-btn" data-format="rgb">Copy</button>
      </div>

      <div class="format-row">
        <label class="tool-label">HSL</label>
        <div class="format-inputs hsl-inputs">
          <div class="number-field">
            <span class="field-hint">H</span>
            <input type="number" id="hslH" min="0" max="360" value="217" />
          </div>
          <div class="number-field">
            <span class="field-hint">S</span>
            <input type="number" id="hslS" min="0" max="100" value="91" />
          </div>
          <div class="number-field">
            <span class="field-hint">L</span>
            <input type="number" id="hslL" min="0" max="100" value="60" />
          </div>
        </div>
        <button type="button" class="copy-btn" data-format="hsl">Copy</button>
      </div>
    </div>
  </div>

  <AdUnit slot="tool-mid" format="rectangle" />

  <article class="content-section">
    <h2>Understanding Color Formats: HEX, RGB, and HSL</h2>
    <p>Color is a fundamental element of web design, branding, and digital media. Every color displayed on a screen can be described numerically using different notation systems called color formats. The three most widely used formats on the web are HEX, RGB, and HSL. Each represents the same underlying color information but expresses it in a different way, making certain formats better suited to specific tasks. This converter lets you move seamlessly between all three so you always have the exact value you need.</p>

    <h2>HEX Color Codes</h2>
    <p>HEX, short for hexadecimal, is the most common color format in web development. A HEX code is a six-character string prefixed with a hash symbol, such as <code>#3b82f6</code>. The six characters are divided into three pairs: the first two represent the red channel, the middle two represent green, and the last two represent blue. Each pair is a hexadecimal number ranging from 00 (zero intensity) to FF (full intensity), giving 256 possible values per channel and over 16.7 million possible colors in total.</p>
    <p>HEX codes are compact and easy to copy and paste, which is why they became the default color notation in CSS and HTML. Designers often communicate colors using HEX values because they are concise and unambiguous. A shorthand three-character form also exists: <code>#f00</code> is equivalent to <code>#ff0000</code> (pure red), where each character is doubled to produce the full six-digit value. Most design tools, including Figma, Sketch, and Adobe Photoshop, display HEX values prominently in their color pickers.</p>

    <h2>RGB Color Values</h2>
    <p>RGB stands for Red, Green, Blue, the three primary colors of light used by screens and monitors to produce every visible color. In the RGB format, each channel is expressed as a decimal number from 0 to 255. For example, <code>rgb(59, 130, 246)</code> defines a color with 59 units of red, 130 units of green, and 246 units of blue, resulting in a medium blue. When all three channels are at 0, the result is black. When all three are at 255, the result is white.</p>
    <p>RGB is the native color model for digital displays because each pixel on a screen is physically composed of red, green, and blue sub-pixels. The CSS <code>rgb()</code> function makes it easy to use RGB values directly in stylesheets. RGB is particularly useful when you need to adjust individual color channels programmatically, such as dynamically lightening or darkening a color by adding or subtracting a fixed amount from each channel. The format also extends to RGBA, where a fourth parameter controls opacity on a scale from 0 (fully transparent) to 1 (fully opaque).</p>

    <h2>HSL Color Values</h2>
    <p>HSL stands for Hue, Saturation, Lightness, and it represents color in a way that aligns more closely with how humans naturally think about color. Instead of mixing red, green, and blue channels, HSL describes a color by its position on the color wheel (hue, measured in degrees from 0 to 360), its intensity (saturation, a percentage from 0% to 100%), and its brightness (lightness, also a percentage from 0% to 100%).</p>
    <p>Hue at 0 degrees is red, 120 degrees is green, and 240 degrees is blue. Saturation at 100% produces a vivid, pure color, while 0% produces a shade of gray. Lightness at 50% gives the pure color, 0% produces black regardless of hue or saturation, and 100% produces white. For example, <code>hsl(217, 91%, 60%)</code> describes the same medium blue as the HEX and RGB values mentioned above.</p>
    <p>HSL is especially valuable for designers and developers who need to create cohesive color palettes. Because hue, saturation, and lightness are independent axes, you can easily generate variations of a base color. To create a lighter tint, increase the lightness value. To create a muted version, decrease the saturation. To find a complementary color, add 180 degrees to the hue. These intuitive adjustments make HSL the preferred format for building design systems and CSS custom property themes.</p>

    <h2>When to Use Each Format</h2>
    <p>Choosing between HEX, RGB, and HSL depends on the context and what you are trying to accomplish. HEX is ideal for static color values in stylesheets and design specifications because it is compact and universally recognized. When you are writing CSS and simply need to set a color that will not change dynamically, HEX is the most straightforward choice.</p>
    <p>RGB is the best choice when you need to manipulate individual color channels or work with transparency using RGBA. JavaScript color calculations, canvas drawing, image processing, and any situation where you are computing colors mathematically benefit from the 0-to-255 integer scale of RGB. It maps directly to the underlying pixel data of digital images.</p>
    <p>HSL shines when you need to reason about color relationships. Building a color palette, creating hover states that are slightly lighter or darker than the base color, generating accessible color contrast combinations, or theming an application with CSS custom properties are all tasks where HSL's intuitive axes make the work faster and more predictable. Many modern CSS frameworks and design tools have adopted HSL as their primary color format for these reasons.</p>
    <p>In practice, professional designers and developers use all three formats interchangeably, converting between them as needed. A designer might receive a HEX value from a brand guide, convert it to HSL to create a range of tints and shades for a component library, and then use RGB when writing a JavaScript function that blends two colors together. Having a reliable converter eliminates manual calculation and reduces the risk of transcription errors when moving between these formats.</p>

    <h2>Color Conversion Formulas</h2>
    <p>Converting between color formats involves well-defined mathematical transformations. HEX to RGB is the simplest: each pair of hexadecimal characters maps directly to a decimal value between 0 and 255. The conversion from RGB to HSL involves normalizing the red, green, and blue values to a 0-to-1 scale, finding the minimum and maximum channel values, and then calculating hue, saturation, and lightness from those extremes. The reverse conversion from HSL to RGB uses a different algorithm that maps the cylindrical HSL coordinates back to the cubic RGB space through a series of intermediate calculations.</p>
    <p>While the math behind these conversions is straightforward, performing them by hand is tedious and error-prone. Even a single mistyped digit can produce a noticeably different color. This converter handles all of the arithmetic instantly, ensuring that your HEX, RGB, and HSL values always represent exactly the same color. Simply enter a value in any format, and the other two formats update in real time along with the live color preview.</p>

    <h2>Related Tools</h2>
    <ul>
      <li><a href="/tools/json-formatter/">JSON Formatter</a> - Format and validate JSON data instantly.</li>
      <li><a href="/tools/password-generator/">Password Generator</a> - Generate strong, secure random passwords.</li>
      <li><a href="/tools/text-case-converter/">Text Case Converter</a> - Convert text between uppercase, lowercase, title case, and more.</li>
      <li><a href="/tools/base64-encoder-decoder/">Base64 Encoder/Decoder</a> - Encode and decode Base64 strings.</li>
    </ul>
  </article>

  <AdUnit slot="tool-bottom" format="horizontal" />
</BaseLayout>

<style>
  .color-picker-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 20px;
  }
  .color-picker-row input[type="color"] {
    width: 48px;
    height: 36px;
    padding: 2px;
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    background: var(--color-bg);
    cursor: pointer;
  }

  .color-formats {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .format-row {
    display: grid;
    grid-template-columns: 48px 1fr auto;
    align-items: center;
    gap: 12px;
  }
  .format-row .tool-label {
    margin: 0;
    font-size: 0.85rem;
    font-weight: 700;
    white-space: nowrap;
  }

  .format-inputs {
    display: flex;
    gap: 8px;
  }
  .format-inputs input[type="text"] {
    width: 100%;
    max-width: 120px;
    padding: 8px 12px;
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    font-size: 0.9rem;
    font-family: 'Courier New', Consolas, monospace;
    background: var(--color-bg);
    color: var(--color-text);
    box-sizing: border-box;
  }
  .format-inputs input[type="text"]:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
  }

  .number-field {
    display: flex;
    flex-direction: column;
    gap: 2px;
    flex: 1;
    max-width: 80px;
  }
  .field-hint {
    font-size: 0.7rem;
    font-weight: 600;
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .number-field input[type="number"] {
    width: 100%;
    padding: 8px 8px;
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    font-size: 0.9rem;
    font-family: 'Courier New', Consolas, monospace;
    background: var(--color-bg);
    color: var(--color-text);
    box-sizing: border-box;
    -moz-appearance: textfield;
  }
  .number-field input[type="number"]::-webkit-inner-spin-button,
  .number-field input[type="number"]::-webkit-outer-spin-button {
    opacity: 1;
  }
  .number-field input[type="number"]:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
  }

  @media (max-width: 640px) {
    .format-row {
      grid-template-columns: 1fr;
      gap: 6px;
    }
    .format-row .copy-btn {
      justify-self: start;
    }
    .number-field {
      max-width: none;
    }
  }
</style>

<script>
  // --- DOM Elements ---
  const colorPreview = document.getElementById('colorPreview') as HTMLElement;
  const colorPicker = document.getElementById('colorPicker') as HTMLInputElement;
  const hexInput = document.getElementById('hexInput') as HTMLInputElement;
  const rgbR = document.getElementById('rgbR') as HTMLInputElement;
  const rgbG = document.getElementById('rgbG') as HTMLInputElement;
  const rgbB = document.getElementById('rgbB') as HTMLInputElement;
  const hslH = document.getElementById('hslH') as HTMLInputElement;
  const hslS = document.getElementById('hslS') as HTMLInputElement;
  const hslL = document.getElementById('hslL') as HTMLInputElement;
  const copyBtns = document.querySelectorAll<HTMLButtonElement>('.copy-btn[data-format]');

  // --- Conversion Functions ---

  function clamp(val: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, val));
  }

  function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
    let h = hex.replace(/^#/, '');
    if (h.length === 3) {
      h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
    }
    if (!/^[0-9a-fA-F]{6}$/.test(h)) return null;
    return {
      r: parseInt(h.substring(0, 2), 16),
      g: parseInt(h.substring(2, 4), 16),
      b: parseInt(h.substring(4, 6), 16),
    };
  }

  function rgbToHex(r: number, g: number, b: number): string {
    const toHex = (n: number) => clamp(Math.round(n), 0, 255).toString(16).padStart(2, '0');
    return '#' + toHex(r) + toHex(g) + toHex(b);
  }

  function rgbToHsl(r: number, g: number, b: number): { h: number; s: number; l: number } {
    const rn = r / 255;
    const gn = g / 255;
    const bn = b / 255;
    const max = Math.max(rn, gn, bn);
    const min = Math.min(rn, gn, bn);
    const d = max - min;
    let h = 0;
    let s = 0;
    const l = (max + min) / 2;

    if (d !== 0) {
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case rn:
          h = ((gn - bn) / d + (gn < bn ? 6 : 0)) / 6;
          break;
        case gn:
          h = ((bn - rn) / d + 2) / 6;
          break;
        case bn:
          h = ((rn - gn) / d + 4) / 6;
          break;
      }
    }

    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      l: Math.round(l * 100),
    };
  }

  function hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
    const hn = h / 360;
    const sn = s / 100;
    const ln = l / 100;

    if (sn === 0) {
      const gray = Math.round(ln * 255);
      return { r: gray, g: gray, b: gray };
    }

    const hue2rgb = (p: number, q: number, t: number): number => {
      let tt = t;
      if (tt < 0) tt += 1;
      if (tt > 1) tt -= 1;
      if (tt < 1 / 6) return p + (q - p) * 6 * tt;
      if (tt < 1 / 2) return q;
      if (tt < 2 / 3) return p + (q - p) * (2 / 3 - tt) * 6;
      return p;
    };

    const q = ln < 0.5 ? ln * (1 + sn) : ln + sn - ln * sn;
    const p = 2 * ln - q;

    return {
      r: Math.round(hue2rgb(p, q, hn + 1 / 3) * 255),
      g: Math.round(hue2rgb(p, q, hn) * 255),
      b: Math.round(hue2rgb(p, q, hn - 1 / 3) * 255),
    };
  }

  // --- UI Update Helpers ---

  /** Flags to prevent circular updates */
  let updating = false;

  function updateFromRgb(r: number, g: number, b: number): void {
    if (updating) return;
    updating = true;

    const rc = clamp(Math.round(r), 0, 255);
    const gc = clamp(Math.round(g), 0, 255);
    const bc = clamp(Math.round(b), 0, 255);

    const hex = rgbToHex(rc, gc, bc);
    const hsl = rgbToHsl(rc, gc, bc);

    hexInput.value = hex;
    colorPicker.value = hex;
    rgbR.value = String(rc);
    rgbG.value = String(gc);
    rgbB.value = String(bc);
    hslH.value = String(hsl.h);
    hslS.value = String(hsl.s);
    hslL.value = String(hsl.l);

    colorPreview.style.backgroundColor = hex;

    updating = false;
  }

  function updateFromHex(hex: string): void {
    const rgb = hexToRgb(hex);
    if (!rgb) return;
    updateFromRgb(rgb.r, rgb.g, rgb.b);
  }

  function updateFromHsl(h: number, s: number, l: number): void {
    if (updating) return;
    updating = true;

    const hc = clamp(Math.round(h), 0, 360);
    const sc = clamp(Math.round(s), 0, 100);
    const lc = clamp(Math.round(l), 0, 100);

    const rgb = hslToRgb(hc, sc, lc);
    const hex = rgbToHex(rgb.r, rgb.g, rgb.b);

    hexInput.value = hex;
    colorPicker.value = hex;
    rgbR.value = String(rgb.r);
    rgbG.value = String(rgb.g);
    rgbB.value = String(rgb.b);
    hslH.value = String(hc);
    hslS.value = String(sc);
    hslL.value = String(lc);

    colorPreview.style.backgroundColor = hex;

    updating = false;
  }

  // --- Event Listeners ---

  colorPicker.addEventListener('input', () => {
    updateFromHex(colorPicker.value);
  });

  hexInput.addEventListener('input', () => {
    let val = hexInput.value.trim();
    if (!val.startsWith('#')) val = '#' + val;
    updateFromHex(val);
  });

  function onRgbChange(): void {
    updateFromRgb(
      parseInt(rgbR.value, 10) || 0,
      parseInt(rgbG.value, 10) || 0,
      parseInt(rgbB.value, 10) || 0,
    );
  }
  rgbR.addEventListener('input', onRgbChange);
  rgbG.addEventListener('input', onRgbChange);
  rgbB.addEventListener('input', onRgbChange);

  function onHslChange(): void {
    updateFromHsl(
      parseInt(hslH.value, 10) || 0,
      parseInt(hslS.value, 10) || 0,
      parseInt(hslL.value, 10) || 0,
    );
  }
  hslH.addEventListener('input', onHslChange);
  hslS.addEventListener('input', onHslChange);
  hslL.addEventListener('input', onHslChange);

  // --- Copy Buttons ---

  function getFormattedValue(format: string): string {
    switch (format) {
      case 'hex':
        return hexInput.value;
      case 'rgb':
        return 'rgb(' + rgbR.value + ', ' + rgbG.value + ', ' + rgbB.value + ')';
      case 'hsl':
        return 'hsl(' + hslH.value + ', ' + hslS.value + '%, ' + hslL.value + '%)';
      default:
        return '';
    }
  }

  copyBtns.forEach((btn) => {
    btn.addEventListener('click', () => {
      const format = btn.getAttribute('data-format');
      if (!format) return;
      const text = getFormattedValue(format);
      navigator.clipboard.writeText(text).then(() => {
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => {
          btn.textContent = 'Copy';
          btn.classList.remove('copied');
        }, 1500);
      });
    });
  });
</script>
