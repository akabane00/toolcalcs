---
import BaseLayout from '../../layouts/BaseLayout.astro';
import AdUnit from '../../components/AdUnit.astro';
import { getToolBySlug } from '../../data/tools';
import '../../styles/tool.css';

const tool = getToolBySlug('hash-generator')!;

const structuredData = [
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://toolcalcs.com/" },
      { "@type": "ListItem", "position": 2, "name": "Web Tools", "item": "https://toolcalcs.com/tools/" },
      { "@type": "ListItem", "position": 3, "name": "Hash Generator" }
    ]
  },
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "What is a hash function?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "A hash function is a mathematical algorithm that converts input data of any size into a fixed-size output (hash). The same input always produces the same output, but even a tiny change in input produces a completely different hash. Hash functions are one-way — you cannot reverse a hash to find the original input."
        }
      },
      {
        "@type": "Question",
        "name": "Which hash algorithm should I use?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "For security purposes, use SHA-256 or SHA-512. MD5 and SHA-1 are cryptographically broken and should only be used for checksums or non-security purposes. SHA-256 is the most widely used secure hash algorithm today."
        }
      },
      {
        "@type": "Question",
        "name": "Is MD5 still safe to use?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "MD5 is not safe for cryptographic purposes like password hashing or digital signatures because collision attacks have been demonstrated. However, it is still acceptable for non-security uses like file checksums, cache keys, and data deduplication where collision resistance is not critical."
        }
      }
    ]
  },
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Hash Generator",
    "url": "https://toolcalcs.com/tools/hash-generator/",
    "applicationCategory": "DeveloperApplication",
    "operatingSystem": "All",
    "browserRequirements": "Requires JavaScript",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "description": "Generate MD5, SHA-1, SHA-256, SHA-384, and SHA-512 hashes from any text. Free online hash calculator."
  }
];
---

<BaseLayout
  title="Hash Generator - MD5, SHA-1, SHA-256, SHA-512 Online | ToolCalcs"
  description="Generate MD5, SHA-1, SHA-256, SHA-384, and SHA-512 hashes from any text. Free online hash calculator with hex and Base64 output."
  type="article"
  structuredData={structuredData}
>
  <nav class="breadcrumb">
    <a href="/">Home</a> &rsaquo;
    <a href="/tools/">Web Tools</a> &rsaquo;
    <span>Hash Generator</span>
  </nav>

  <h1>Hash Generator</h1>
  <p class="page-desc">Generate cryptographic hash values from any text input. Supports MD5, SHA-1, SHA-256, SHA-384, and SHA-512.</p>

  <div class="tool-box">
    <div class="tool-input-area">
      <div class="output-header">
        <span class="tool-label">Input Text</span>
        <span class="char-count" id="charCount">0 characters</span>
      </div>
      <textarea class="tool-textarea" id="toolInput" placeholder="Type or paste text to hash..." rows="5"></textarea>
    </div>

    <div class="hash-results" id="hashResults">
      <div class="hash-row">
        <div class="hash-label-row">
          <span class="hash-name">MD5 <span class="hash-warn">(insecure)</span></span>
          <button class="copy-btn" data-target="hashMD5" type="button">Copy</button>
        </div>
        <input type="text" class="hash-output" id="hashMD5" readonly value="" />
      </div>
      <div class="hash-row">
        <div class="hash-label-row">
          <span class="hash-name">SHA-1 <span class="hash-warn">(insecure)</span></span>
          <button class="copy-btn" data-target="hashSHA1" type="button">Copy</button>
        </div>
        <input type="text" class="hash-output" id="hashSHA1" readonly value="" />
      </div>
      <div class="hash-row">
        <div class="hash-label-row">
          <span class="hash-name">SHA-256</span>
          <button class="copy-btn" data-target="hashSHA256" type="button">Copy</button>
        </div>
        <input type="text" class="hash-output" id="hashSHA256" readonly value="" />
      </div>
      <div class="hash-row">
        <div class="hash-label-row">
          <span class="hash-name">SHA-384</span>
          <button class="copy-btn" data-target="hashSHA384" type="button">Copy</button>
        </div>
        <input type="text" class="hash-output" id="hashSHA384" readonly value="" />
      </div>
      <div class="hash-row">
        <div class="hash-label-row">
          <span class="hash-name">SHA-512</span>
          <button class="copy-btn" data-target="hashSHA512" type="button">Copy</button>
        </div>
        <input type="text" class="hash-output" id="hashSHA512" readonly value="" />
      </div>
    </div>

    <div class="tool-options" style="margin-top:12px;">
      <div class="tool-option">
        <label for="outputFormat">Output Format</label>
        <select id="outputFormat">
          <option value="hex" selected>Hexadecimal (lowercase)</option>
          <option value="hexupper">Hexadecimal (uppercase)</option>
          <option value="base64">Base64</option>
        </select>
      </div>
    </div>
  </div>

  <AdUnit slot="hash-mid" format="rectangle" />

  <article class="content-section">
    <h2>What Is a Hash Function?</h2>
    <p>A cryptographic hash function is a mathematical algorithm that takes input data of arbitrary size and produces a fixed-size output called a hash, digest, or checksum. Hash functions are designed to be deterministic (the same input always produces the same output), fast to compute, and practically impossible to reverse. Even a single-character change in the input produces a completely different hash — a property known as the avalanche effect.</p>
    <p>Hash functions are fundamental to modern computing and security. They are used in password storage, digital signatures, data integrity verification, blockchain technology, file deduplication, and many other applications.</p>

    <h2>Supported Hash Algorithms</h2>
    <h3>MD5 (128-bit)</h3>
    <p>Developed by Ronald Rivest in 1991, MD5 produces a 128-bit (32 hex character) hash. While once widely used, MD5 is now considered cryptographically broken due to demonstrated collision attacks. It should not be used for security-sensitive applications. However, it remains useful for checksums, cache keys, and non-cryptographic fingerprinting.</p>

    <h3>SHA-1 (160-bit)</h3>
    <p>Published by NIST in 1995, SHA-1 produces a 160-bit (40 hex character) hash. In 2017, Google demonstrated a practical collision attack (SHAttered), and SHA-1 is now considered insecure for cryptographic use. Major browsers and certificate authorities have deprecated SHA-1 for SSL/TLS certificates.</p>

    <h3>SHA-256 (256-bit)</h3>
    <p>Part of the SHA-2 family designed by the NSA and published by NIST in 2001. SHA-256 produces a 256-bit (64 hex character) hash. It is widely used in security applications, blockchain (Bitcoin uses SHA-256), digital certificates, and password hashing. No practical attacks have been found against SHA-256.</p>

    <h3>SHA-384 (384-bit)</h3>
    <p>Also part of the SHA-2 family, SHA-384 is a truncated version of SHA-512. It produces a 384-bit (96 hex character) hash and provides a higher security margin than SHA-256. It is commonly used in government and financial applications requiring stronger security guarantees.</p>

    <h3>SHA-512 (512-bit)</h3>
    <p>The largest member of the SHA-2 family commonly used. SHA-512 produces a 512-bit (128 hex character) hash. On 64-bit processors, SHA-512 can actually be faster than SHA-256 because it processes data in 64-bit words. It is preferred when maximum hash security is needed.</p>

    <h2>Hash Function Properties</h2>
    <ul>
      <li><strong>Deterministic:</strong> The same input always produces the same hash output.</li>
      <li><strong>Fixed output size:</strong> Regardless of input size, the hash is always the same length (e.g., 256 bits for SHA-256).</li>
      <li><strong>Avalanche effect:</strong> A small change in input produces a dramatically different hash.</li>
      <li><strong>Pre-image resistance:</strong> Given a hash, it is computationally infeasible to find the original input.</li>
      <li><strong>Collision resistance:</strong> It is computationally infeasible to find two different inputs that produce the same hash.</li>
      <li><strong>Fast computation:</strong> Hashes can be computed quickly for any input size.</li>
    </ul>

    <h2>Common Uses of Hash Functions</h2>
    <ul>
      <li><strong>Password storage:</strong> Passwords are hashed before storage so that even if the database is compromised, the original passwords are not exposed. (Note: purpose-built password hashing functions like bcrypt or Argon2 are preferred over raw SHA-256.)</li>
      <li><strong>File integrity:</strong> Download sites provide hash checksums so you can verify that a downloaded file has not been corrupted or tampered with.</li>
      <li><strong>Digital signatures:</strong> Hash functions are used to create a digest of a message that is then encrypted with a private key.</li>
      <li><strong>Blockchain:</strong> Cryptocurrencies like Bitcoin use SHA-256 to link blocks together and verify transactions.</li>
      <li><strong>Data deduplication:</strong> Storage systems use hashes to identify duplicate data blocks and avoid storing them multiple times.</li>
    </ul>

    <h2>Frequently Asked Questions</h2>

    <h3>What is a hash function?</h3>
    <p>A hash function converts input data of any size into a fixed-size output. The same input always produces the same output, but even a tiny change produces a completely different hash. Hash functions are one-way — you cannot reverse a hash to find the original input.</p>

    <h3>Which hash algorithm should I use?</h3>
    <p>For security purposes, use SHA-256 or SHA-512. MD5 and SHA-1 are cryptographically broken and should only be used for non-security purposes like checksums or cache keys. SHA-256 is the most widely used secure hash algorithm today.</p>

    <h3>Is MD5 still safe to use?</h3>
    <p>MD5 is not safe for cryptographic purposes because collision attacks have been demonstrated. It remains acceptable for non-security uses like file checksums and data deduplication where collision resistance is not critical.</p>

    <h2>Related Tools</h2>
    <ul>
      <li><a href="/tools/base64-encoder-decoder/">Base64 Encoder/Decoder</a> — Encode or decode Base64 strings.</li>
      <li><a href="/tools/password-generator/">Password Generator</a> — Generate strong, secure passwords.</li>
    </ul>
  </article>

  <AdUnit slot="hash-bottom" format="horizontal" />
</BaseLayout>

<style>
  .char-count { font-size: 0.8rem; color: var(--color-text-muted); }
  .hash-results { display: flex; flex-direction: column; gap: 12px; margin-top: 16px; }
  .hash-row { display: flex; flex-direction: column; gap: 4px; }
  .hash-label-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .hash-name { font-size: 0.85rem; font-weight: 600; color: var(--color-text); }
  .hash-warn { font-size: 0.75rem; color: #ef4444; font-weight: 500; }
  .hash-output {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--color-border);
    border-radius: var(--radius);
    font-family: 'Courier New', Consolas, monospace;
    font-size: 0.8rem;
    background: var(--color-bg);
    color: var(--color-text);
    word-break: break-all;
  }
  .hash-output:focus {
    outline: none;
    border-color: var(--color-primary);
  }
</style>

<script>
  (function () {
    'use strict';

    const inputEl = document.getElementById('toolInput') as HTMLTextAreaElement;
    const formatEl = document.getElementById('outputFormat') as HTMLSelectElement;
    const charCount = document.getElementById('charCount')!;

    const hashIds = ['hashMD5', 'hashSHA1', 'hashSHA256', 'hashSHA384', 'hashSHA512'];
    const hashEls = hashIds.map(id => document.getElementById(id) as HTMLInputElement);

    // --- MD5 implementation (not in Web Crypto API) ---
    function md5(str: string): string {
      const k = new Uint32Array([
        0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,
        0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193,0xa679438e,0x49b40821,
        0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8,
        0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,
        0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,
        0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05,0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,
        0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,
        0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391,
      ]);
      const s = [7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,
                 5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,
                 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,
                 6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21];

      const bytes = new TextEncoder().encode(str);
      const bitLen = bytes.length * 8;
      const padLen = ((bytes.length + 8) % 64 === 0) ? 0 : 64 - ((bytes.length + 8) % 64);
      const total = bytes.length + 1 + padLen + 8;
      const buf = new Uint8Array(total);
      buf.set(bytes);
      buf[bytes.length] = 0x80;
      const dv = new DataView(buf.buffer);
      dv.setUint32(total - 8, bitLen & 0xffffffff, true);
      dv.setUint32(total - 4, Math.floor(bitLen / 0x100000000), true);

      let a0 = 0x67452301, b0 = 0xefcdab89, c0 = 0x98badcfe, d0 = 0x10325476;

      for (let i = 0; i < total; i += 64) {
        const m = new Uint32Array(16);
        for (let j = 0; j < 16; j++) m[j] = dv.getUint32(i + j * 4, true);
        let a = a0, b = b0, c = c0, d = d0;
        for (let j = 0; j < 64; j++) {
          let f: number, g: number;
          if (j < 16) { f = (b & c) | (~b & d); g = j; }
          else if (j < 32) { f = (d & b) | (~d & c); g = (5 * j + 1) % 16; }
          else if (j < 48) { f = b ^ c ^ d; g = (3 * j + 5) % 16; }
          else { f = c ^ (b | ~d); g = (7 * j) % 16; }
          const tmp = d;
          d = c;
          c = b;
          const x = (a + f + k[j] + m[g]) | 0;
          b = (b + ((x << s[j]) | (x >>> (32 - s[j])))) | 0;
          a = tmp;
        }
        a0 = (a0 + a) | 0;
        b0 = (b0 + b) | 0;
        c0 = (c0 + c) | 0;
        d0 = (d0 + d) | 0;
      }

      const result = new Uint8Array(16);
      const rdv = new DataView(result.buffer);
      rdv.setUint32(0, a0, true);
      rdv.setUint32(4, b0, true);
      rdv.setUint32(8, c0, true);
      rdv.setUint32(12, d0, true);
      return result.reduce((s, b) => s + b.toString(16).padStart(2, '0'), '');
    }

    // --- Web Crypto hashes ---
    async function cryptoHash(algo: string, text: string): Promise<ArrayBuffer> {
      const data = new TextEncoder().encode(text);
      return crypto.subtle.digest(algo, data);
    }

    function bufToHex(buf: ArrayBuffer): string {
      return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
    }
    function bufToBase64(buf: ArrayBuffer): string {
      return btoa(String.fromCharCode(...new Uint8Array(buf)));
    }

    let lastInput = '';
    let cachedHashes: { md5: string; sha1: ArrayBuffer; sha256: ArrayBuffer; sha384: ArrayBuffer; sha512: ArrayBuffer } | null = null;

    async function computeHashes(text: string) {
      const [sha1, sha256, sha384, sha512] = await Promise.all([
        cryptoHash('SHA-1', text),
        cryptoHash('SHA-256', text),
        cryptoHash('SHA-384', text),
        cryptoHash('SHA-512', text),
      ]);
      cachedHashes = { md5: md5(text), sha1, sha256, sha384, sha512 };
      lastInput = text;
      displayHashes();
    }

    function displayHashes() {
      if (!cachedHashes) return;
      const fmt = formatEl.value;
      const format = (buf: ArrayBuffer) => {
        if (fmt === 'base64') return bufToBase64(buf);
        const hex = bufToHex(buf);
        return fmt === 'hexupper' ? hex.toUpperCase() : hex;
      };
      const md5Fmt = (hex: string) => {
        if (fmt === 'base64') {
          const bytes = hex.match(/.{2}/g)!.map(b => parseInt(b, 16));
          return btoa(String.fromCharCode(...bytes));
        }
        return fmt === 'hexupper' ? hex.toUpperCase() : hex;
      };
      hashEls[0].value = md5Fmt(cachedHashes.md5);
      hashEls[1].value = format(cachedHashes.sha1);
      hashEls[2].value = format(cachedHashes.sha256);
      hashEls[3].value = format(cachedHashes.sha384);
      hashEls[4].value = format(cachedHashes.sha512);
    }

    function update() {
      const text = inputEl.value;
      charCount.textContent = `${text.length} character${text.length !== 1 ? 's' : ''}`;
      if (text === lastInput && cachedHashes) {
        displayHashes();
        return;
      }
      if (text.length === 0) {
        hashEls.forEach(el => el.value = '');
        cachedHashes = null;
        lastInput = '';
        return;
      }
      computeHashes(text);
    }

    // Copy button
    document.querySelectorAll('.copy-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const targetId = (btn as HTMLElement).dataset.target!;
        const el = document.getElementById(targetId) as HTMLInputElement;
        if (!el.value) return;
        navigator.clipboard.writeText(el.value).then(() => {
          btn.textContent = 'Copied!';
          btn.classList.add('copied');
          setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
        }).catch(() => {
          el.select();
          document.execCommand('copy');
        });
      });
    });

    inputEl.addEventListener('input', update);
    formatEl.addEventListener('change', () => displayHashes());
    update();
  })();
</script>
